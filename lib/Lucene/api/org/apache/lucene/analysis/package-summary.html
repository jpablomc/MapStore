<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_08) on Wed Mar 04 21:57:48 GMT 2009 -->
<TITLE>
org.apache.lucene.analysis (Lucene 2.4.1 API)
</TITLE>

<META NAME="keywords" CONTENT="org.apache.lucene.analysis package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="org.apache.lucene.analysis (Lucene 2.4.1 API)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/lucene/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/lucene/analysis/br/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/lucene/analysis/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.apache.lucene.analysis
</H2>
API and code to convert text into indexable/searchable tokens.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A></B></TD>
<TD>An Analyzer builds TokenStreams, which analyze text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/CachingTokenFilter.html" title="class in org.apache.lucene.analysis">CachingTokenFilter</A></B></TD>
<TD>This class can be used if the Tokens of a TokenStream
 are intended to be consumed more than once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/CharArraySet.html" title="class in org.apache.lucene.analysis">CharArraySet</A></B></TD>
<TD>A simple class that stores Strings as char[]'s in a
 hash table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/CharTokenizer.html" title="class in org.apache.lucene.analysis">CharTokenizer</A></B></TD>
<TD>An abstract base class for simple, character-oriented tokenizers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/ISOLatin1AccentFilter.html" title="class in org.apache.lucene.analysis">ISOLatin1AccentFilter</A></B></TD>
<TD>A filter that replaces accented characters in the ISO Latin 1 character set 
 (ISO-8859-1) by their unaccented equivalent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/KeywordAnalyzer.html" title="class in org.apache.lucene.analysis">KeywordAnalyzer</A></B></TD>
<TD>"Tokenizes" the entire stream as a single token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/KeywordTokenizer.html" title="class in org.apache.lucene.analysis">KeywordTokenizer</A></B></TD>
<TD>Emits the entire input as a single token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/LengthFilter.html" title="class in org.apache.lucene.analysis">LengthFilter</A></B></TD>
<TD>Removes words that are too long and too short from the stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/LetterTokenizer.html" title="class in org.apache.lucene.analysis">LetterTokenizer</A></B></TD>
<TD>A LetterTokenizer is a tokenizer that divides text at non-letters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/LowerCaseFilter.html" title="class in org.apache.lucene.analysis">LowerCaseFilter</A></B></TD>
<TD>Normalizes token text to lower case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/LowerCaseTokenizer.html" title="class in org.apache.lucene.analysis">LowerCaseTokenizer</A></B></TD>
<TD>LowerCaseTokenizer performs the function of LetterTokenizer
 and LowerCaseFilter together.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/PerFieldAnalyzerWrapper.html" title="class in org.apache.lucene.analysis">PerFieldAnalyzerWrapper</A></B></TD>
<TD>This analyzer is used to facilitate scenarios where different
 fields require different analysis techniques.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/PorterStemFilter.html" title="class in org.apache.lucene.analysis">PorterStemFilter</A></B></TD>
<TD>Transforms the token stream as per the Porter stemming algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/SimpleAnalyzer.html" title="class in org.apache.lucene.analysis">SimpleAnalyzer</A></B></TD>
<TD>An Analyzer that filters LetterTokenizer with LowerCaseFilter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/SinkTokenizer.html" title="class in org.apache.lucene.analysis">SinkTokenizer</A></B></TD>
<TD>A SinkTokenizer can be used to cache Tokens for use in an Analyzer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/StopAnalyzer.html" title="class in org.apache.lucene.analysis">StopAnalyzer</A></B></TD>
<TD>Filters LetterTokenizer with LowerCaseFilter and StopFilter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/StopFilter.html" title="class in org.apache.lucene.analysis">StopFilter</A></B></TD>
<TD>Removes stop words from a token stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/TeeTokenFilter.html" title="class in org.apache.lucene.analysis">TeeTokenFilter</A></B></TD>
<TD>Works in conjunction with the SinkTokenizer to provide the ability to set aside tokens
 that have already been analyzed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Token.html" title="class in org.apache.lucene.analysis">Token</A></B></TD>
<TD>A Token is an occurrence of a term from the text of a field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/TokenFilter.html" title="class in org.apache.lucene.analysis">TokenFilter</A></B></TD>
<TD>A TokenFilter is a TokenStream whose input is another token stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis">Tokenizer</A></B></TD>
<TD>A Tokenizer is a TokenStream whose input is a Reader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis">TokenStream</A></B></TD>
<TD>A TokenStream enumerates the sequence of tokens, either from
  fields of a document or from query text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/WhitespaceAnalyzer.html" title="class in org.apache.lucene.analysis">WhitespaceAnalyzer</A></B></TD>
<TD>An Analyzer that uses WhitespaceTokenizer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/WhitespaceTokenizer.html" title="class in org.apache.lucene.analysis">WhitespaceTokenizer</A></B></TD>
<TD>A WhitespaceTokenizer is a tokenizer that divides text at whitespace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/WordlistLoader.html" title="class in org.apache.lucene.analysis">WordlistLoader</A></B></TD>
<TD>Loader for text files that represent a list of stopwords.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.apache.lucene.analysis Description
</H2>

<P>
<p>API and code to convert text into indexable/searchable tokens.  Covers <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> and related classes.</p>
<h2>Parsing? Tokenization? Analysis!</h2>
<p>
Lucene, indexing and search library, accepts only plain text input.
<p>
<h2>Parsing</h2>
<p>
Applications that build their search capabilities upon Lucene may support documents in various formats &ndash; HTML, XML, PDF, Word &ndash; just to name a few.
Lucene does not care about the <i>Parsing</i> of these and other document formats, and it is the responsibility of the 
application using Lucene to use an appropriate <i>Parser</i> to convert the original format into plain text before passing that plain text to Lucene.
<p>
<h2>Tokenization</h2>
<p>
Plain text passed to Lucene for indexing goes through a process generally called tokenization &ndash; namely breaking of the 
input text into small indexing elements &ndash; 
<A HREF="../../../../org/apache/lucene/analysis/Token.html" title="class in org.apache.lucene.analysis"><CODE>Tokens</CODE></A>.
The way input text is broken into tokens very 
much dictates further capabilities of search upon that text. 
For instance, sentences beginnings and endings can be identified to provide for more accurate phrase 
and proximity searches (though sentence identification is not provided by Lucene).
<p>
In some cases simply breaking the input text into tokens is not enough &ndash; a deeper <i>Analysis</i> is needed,
providing for several functions, including (but not limited to):
<ul>
  <li><a href="http://en.wikipedia.org/wiki/Stemming">Stemming</a> &ndash; 
      Replacing of words by their stems. 
      For instance with English stemming "bikes" is replaced by "bike"; 
      now query "bike" can find both documents containing "bike" and those containing "bikes".
  </li>
  <li><a href="http://en.wikipedia.org/wiki/Stop_words">Stop Words Filtering</a> &ndash; 
      Common words like "the", "and" and "a" rarely add any value to a search.
      Removing them shrinks the index size and increases performance.
      It may also reduce some "noise" and actually improve search quality.
  </li>
  <li><a href="http://en.wikipedia.org/wiki/Text_normalization">Text Normalization</a> &ndash; 
      Stripping accents and other character markings can make for better searching.
  </li>
  <li><a href="http://en.wikipedia.org/wiki/Synonym">Synonym Expansion</a> &ndash; 
      Adding in synonyms at the same token position as the current word can mean better 
      matching when users search with words in the synonym set.
  </li>
</ul> 
<p>
<h2>Core Analysis</h2>
<p>
  The analysis package provides the mechanism to convert Strings and Readers into tokens that can be indexed by Lucene.  There
  are three main classes in the package from which all analysis processes are derived.  These are:
  <ul>
    <li><A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> &ndash; An Analyzer is responsible for building a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A> which can be consumed
    by the indexing and searching processes.  See below for more information on implementing your own Analyzer.</li>
    <li><A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> &ndash; A Tokenizer is a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A> and is responsible for breaking
    up incoming text into <A HREF="../../../../org/apache/lucene/analysis/Token.html" title="class in org.apache.lucene.analysis"><CODE>Token</CODE></A>s.  In most cases, an Analyzer will use a Tokenizer as the first step in
    the analysis process.</li>
    <li><A HREF="../../../../org/apache/lucene/analysis/TokenFilter.html" title="class in org.apache.lucene.analysis"><CODE>TokenFilter</CODE></A> &ndash; A TokenFilter is also a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A> and is responsible
    for modifying <A HREF="../../../../org/apache/lucene/analysis/Token.html" title="class in org.apache.lucene.analysis"><CODE>Token</CODE></A>s that have been created by the Tokenizer.  Common modifications performed by a
    TokenFilter are: deletion, stemming, synonym injection, and down casing.  Not all Analyzers require TokenFilters</li>
  </ul>
</p>
<h2>Hints, Tips and Traps</h2>
<p>
   The synergy between <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> and <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A>
   is sometimes confusing. To ease on this confusion, some clarifications:
   <ul>
      <li>The <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> is responsible for the entire task of 
          <u>creating</u> tokens out of the input text, while the <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A>
          is only responsible for <u>breaking</u> the input text into tokens. Very likely, tokens created 
          by the <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> would be modified or even omitted 
          by the <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> (via one or more
          <A HREF="../../../../org/apache/lucene/analysis/TokenFilter.html" title="class in org.apache.lucene.analysis"><CODE>TokenFilter</CODE></A>s) before being returned.
       </li>
       <li><A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> is a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A>, 
           but <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> is not.
       </li>
       <li><A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> is "field aware", but 
           <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> is not.
       </li>
   </ul>
</p>
<p>
  Lucene Java provides a number of analysis capabilities, the most commonly used one being the <A HREF="../../../../org/apache/lucene/analysis/standard/StandardAnalyzer.html" title="class in org.apache.lucene.analysis.standard"><CODE>StandardAnalyzer</CODE></A>.  Many applications will have a long and industrious life with nothing more
  than the StandardAnalyzer.  However, there are a few other classes/packages that are worth mentioning:
  <ol>
    <li><A HREF="../../../../org/apache/lucene/analysis/PerFieldAnalyzerWrapper.html" title="class in org.apache.lucene.analysis"><CODE>PerFieldAnalyzerWrapper</CODE></A> &ndash; Most Analyzers perform the same operation on all
      <A HREF="../../../../org/apache/lucene/document/Field.html" title="class in org.apache.lucene.document"><CODE>Field</CODE></A>s.  The PerFieldAnalyzerWrapper can be used to associate a different Analyzer with different
      <A HREF="../../../../org/apache/lucene/document/Field.html" title="class in org.apache.lucene.document"><CODE>Field</CODE></A>s.</li>
    <li>The contrib/analyzers library located at the root of the Lucene distribution has a number of different Analyzer implementations to solve a variety
    of different problems related to searching.  Many of the Analyzers are designed to analyze non-English languages.</li>
    <li>The contrib/snowball library 
        located at the root of the Lucene distribution has Analyzer and TokenFilter 
        implementations for a variety of Snowball stemmers.  
        See <a href="http://snowball.tartarus.org">http://snowball.tartarus.org</a> 
        for more information on Snowball stemmers.</li>
    <li>There are a variety of Tokenizer and TokenFilter implementations in this package.  Take a look around, chances are someone has implemented what you need.</li>
  </ol>
</p>
<p>
  Analysis is one of the main causes of performance degradation during indexing.  Simply put, the more you analyze the slower the indexing (in most cases).
  Perhaps your application would be just fine using the simple <A HREF="../../../../org/apache/lucene/analysis/WhitespaceTokenizer.html" title="class in org.apache.lucene.analysis"><CODE>WhitespaceTokenizer</CODE></A> combined with a
  <A HREF="../../../../org/apache/lucene/analysis/StopFilter.html" title="class in org.apache.lucene.analysis"><CODE>StopFilter</CODE></A>. The contrib/benchmark library can be useful for testing out the speed of the analysis process.
</p>
<h2>Invoking the Analyzer</h2>
<p>
  Applications usually do not invoke analysis &ndash; Lucene does it for them:
  <ul>
    <li>At indexing, as a consequence of 
        <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(org.apache.lucene.document.Document)"><CODE>addDocument(doc)</CODE></A>,
        the Analyzer in effect for indexing is invoked for each indexed field of the added document.
    </li>
    <li>At search, as a consequence of
        <A HREF="../../../../org/apache/lucene/queryParser/QueryParser.html#parse(java.lang.String)"><CODE>QueryParser.parse(queryText)</CODE></A>,
        the QueryParser may invoke the Analyzer in effect.
        Note that for some queries analysis does not take place, e.g. wildcard queries.
    </li>
  </ul>
  However an application might invoke Analysis of any text for testing or for any other purpose, something like:
  <PRE>
      Analyzer analyzer = new StandardAnalyzer(); // or any other analyzer
      TokenStream ts = analyzer.tokenStream("myfield",new StringReader("some text goes here"));
      Token t = ts.next();
      while (t!=null) {
        System.out.println("token: "+t));
        t = ts.next();
      }
  </PRE>
</p>
<h2>Indexing Analysis vs. Search Analysis</h2>
<p>
  Selecting the "correct" analyzer is crucial
  for search quality, and can also affect indexing and search performance.
  The "correct" analyzer differs between applications.
  Lucene java's wiki page 
  <a href="http://wiki.apache.org/lucene-java/AnalysisParalysis">AnalysisParalysis</a> 
  provides some data on "analyzing your analyzer".
  Here are some rules of thumb:
  <ol>
    <li>Test test test... (did we say test?)</li>
    <li>Beware of over analysis &ndash; might hurt indexing performance.</li>
    <li>Start with same analyzer for indexing and search, otherwise searches would not find what they are supposed to...</li>
    <li>In some cases a different analyzer is required for indexing and search, for instance:
        <ul>
           <li>Certain searches require more stop words to be filtered. (I.e. more than those that were filtered at indexing.)</li>
           <li>Query expansion by synonyms, acronyms, auto spell correction, etc.</li>
        </ul>
        This might sometimes require a modified analyzer &ndash; see the next section on how to do that.
    </li>
  </ol>
</p>
<h2>Implementing your own Analyzer</h2>
<p>Creating your own Analyzer is straightforward. It usually involves either wrapping an existing Tokenizer and  set of TokenFilters to create a new Analyzer
or creating both the Analyzer and a Tokenizer or TokenFilter.  Before pursuing this approach, you may find it worthwhile
to explore the contrib/analyzers library and/or ask on the java-user@lucene.apache.org mailing list first to see if what you need already exists.
If you are still committed to creating your own Analyzer or TokenStream derivation (Tokenizer or TokenFilter) have a look at
the source code of any one of the many samples located in this package.
</p>
<p>
  The following sections discuss some aspects of implementing your own analyzer.
</p>
<h3>Field Section Boundaries</h2>
<p>
  When <A HREF="../../../../org/apache/lucene/document/Document.html#add(org.apache.lucene.document.Fieldable)"><CODE>document.add(field)</CODE></A>
  is called multiple times for the same field name, we could say that each such call creates a new 
  section for that field in that document. 
  In fact, a separate call to 
  <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html#tokenStream(java.lang.String, java.io.Reader)"><CODE>tokenStream(field,reader)</CODE></A>
  would take place for each of these so called "sections".
  However, the default Analyzer behavior is to treat all these sections as one large section. 
  This allows phrase search and proximity search to seamlessly cross 
  boundaries between these "sections".
  In other words, if a certain field "f" is added like this:
  <PRE>
      document.add(new Field("f","first ends",...);
      document.add(new Field("f","starts two",...);
      indexWriter.addDocument(document);
  </PRE>
  Then, a phrase search for "ends starts" would find that document.
  Where desired, this behavior can be modified by introducing a "position gap" between consecutive field "sections", 
  simply by overriding 
  <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html#getPositionIncrementGap(java.lang.String)"><CODE>Analyzer.getPositionIncrementGap(fieldName)</CODE></A>:
  <PRE>
      Analyzer myAnalyzer = new StandardAnalyzer() {
         public int getPositionIncrementGap(String fieldName) {
           return 10;
         }
      };
  </PRE>
</p>
<h3>Token Position Increments</h2>
<p>
   By default, all tokens created by Analyzers and Tokenizers have a 
   <A HREF="../../../../org/apache/lucene/analysis/Token.html#getPositionIncrement()"><CODE>position increment</CODE></A> of one.
   This means that the position stored for that token in the index would be one more than
   that of the previous token.
   Recall that phrase and proximity searches rely on position info.
</p>
<p>
   If the selected analyzer filters the stop words "is" and "the", then for a document 
   containing the string "blue is the sky", only the tokens "blue", "sky" are indexed, 
   with position("sky") = 1 + position("blue"). Now, a phrase query "blue is the sky"
   would find that document, because the same analyzer filters the same stop words from
   that query. But also the phrase query "blue sky" would find that document.
</p>
<p>   
   If this behavior does not fit the application needs,
   a modified analyzer can be used, that would increment further the positions of
   tokens following a removed stop word, using
   <A HREF="../../../../org/apache/lucene/analysis/Token.html#setPositionIncrement(int)"><CODE>Token.setPositionIncrement(int)</CODE></A>.
   This can be done with something like:
   <PRE>
      public TokenStream tokenStream(final String fieldName, Reader reader) {
        final TokenStream ts = someAnalyzer.tokenStream(fieldName, reader);
        TokenStream res = new TokenStream() {
          public Token next() throws IOException {
            int extraIncrement = 0;
            while (true) {
              Token t = ts.next();
              if (t!=null) {
                if (stopWords.contains(t.termText())) {
                  extraIncrement++; // filter this word
                  continue;
                } 
                if (extraIncrement>0) {
                  t.setPositionIncrement(t.getPositionIncrement()+extraIncrement);
                }
              }
              return t;
            }
          }
        };
        return res;
      }
   </PRE>
   Now, with this modified analyzer, the phrase query "blue sky" would find that document.
   But note that this is yet not a perfect solution, because any phrase query "blue w1 w2 sky"
   where both w1 and w2 are stop words would match that document.
</p>
<p>
   Few more use cases for modifying position increments are:
   <ol>
     <li>Inhibiting phrase and proximity matches in sentence boundaries &ndash; for this, a tokenizer that 
         identifies a new sentence can add 1 to the position increment of the first token of the new sentence.</li>
     <li>Injecting synonyms &ndash; here, synonyms of a token should be added after that token, 
         and their position increment should be set to 0.
         As result, all synonyms of a token would be considered to appear in exactly the 
         same position as that token, and so would they be seen by phrase and proximity searches.</li>
   </ol>
</p>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/lucene/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/lucene/analysis/br/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/lucene/analysis/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Copyright &copy; 2000-2009 Apache Software Foundation.  All Rights Reserved.
</BODY>
</HTML>
